/*
 * Copyright (C) 2013 Kamil Foryszewski 
 *
 * Cape for IRYS robot 
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/dts-v1/;
/plugin/;

/ {
	compatible = "ti,beaglebone", "ti,beaglebone-black", "ti,beaglebone-green";

	/* identification */
	part-number = "BB-IRYS";
	version = "00A0";

	/* state the resources this cape uses */
	exclusive-use =
		/* the pin header uses */
		"P9.19",	/* i2c2_sda */
		"P9.20",	/* i2c2_scl */
		"P9.11", 	/* Motor Left Enable	*/
		"P9.12", 	/* Motor Right Direction	*/
		"P9.13", 	/* Motor Left Step	*/
		"P9.14", 	/* Motor Right Step */
		"P9.15", 	/* Motor Left Direction	*/
		"P9.16", 	/* Motor Right Enable   */
		"P9.28", 	/* SPI1_CS0 	*/
		"P9.29", 	/* SPI1_MISO   */
		"P9.30", 	/* SPI1_MOSI	*/
		"P9.31", 	/* SPI1_SCLK	*/
		"P9.36", 	/* AIN5        */
		"P9.38", 	/* AIN3        */
		"P9.40", 	/* AIN1        */
        	"P8.11", 	/* Motor Left M0* /
        	"P8.13", 	/* Motor Left M1 */
        	"P8.17", 	/* Motor Right M0 */
        	"P8.19", 	/* Motor Right M1 */
		/* the hardware ip uses */
		"i2c2";

	fragment@0 {
		target = <&am33xx_pinmux>;
		__overlay__ {
			bb_i2c2_pins: pinmux_bb_i2c2_pins {
				pinctrl-single,pins = <
					0x178 0x73	/* i2c2_sda, SLEWCTRL_SLOW | INPUT_PULLUP | MODE3 */
					0x17c 0x73	/* i2c2_scl, SLEWCTRL_SLOW | INPUT_PULLUP | MODE3 */
				>;
			};

			bone_spi1_pins: pinmux_spi1_pins {
               			 pinctrl-single,pins = <
                    			0x190 0x13	/* P9_31 = mcasp0_aclkx.spi1_sclk				, OUTPUT_PULLUP | MODE3 */
                			0x194 0x33	/* P9_29 = mcasp0_fsx.spi1_d0					, INPUT_PULLUP  | MODE3 */
                    			0x198 0x13	/* P9_30 = mcasp0_axr0.spi1_d1					, OUTPUT_PULLUP | MODE3 */
                    			0x19c 0x13	/* P9_28 = mcasp0_ahclkr.spi1_cs0				, OUTPUT_PULLUP | MODE3 */					
                    			0x164 0x12  	/* P9_42 = GPIO0_7 =  eCAP0_in_PWM0_out.gpio0[7] 		, OUTPUT_PULLUP | MODE2 */
                		>;
            		};				

			stepper_pins: pinmux_stepper_pins{
				pinctrl-single,pins = <

				    	0x034 0x07 // P8_11 (22) = LeftM0 		= GPIO1_13	
				    	0x024 0x07 // P8_13 (24) = LeftM1	 	= GPIO0_23
					0x02C 0x07 // P8_17 (6)  = RightM0	 	= GPIO0_27
				    	0x020 0x07 // P8_19 (25) = RightM1	 	= GPIO0_22

					0x070 0x07 // P9_11 = Motor Left Enable  	= GPIO0_30
					0x078 0x07 // P9_12 = Motor Right Direction 	= GPIO1_60
					0x074 0x07 // P9_13 = Motor Left Step  		= GPIO0_31
					0x048 0x07 // P9_14 = Motor Right Step  	= GPIO0_50
					0x040 0x07 // P9_15 = Motor Left Direction 	= GPIO1_48
					0x04C 0x07 // P9_16 = Motor Right Enable  	= GPIO0_51


				>;
			};
		
		};
	};

	fragment@1 {
		target = <&i2c2>;
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&bb_i2c2_pins>;

			/* this is the configuration part */
			clock-frequency = <100000>;

			#address-cells = <1>;
			#size-cells = <0>;

			/* add any i2c devices on the bus here */

		};
	};

	fragment@2 {
		target = <&spi1>;
		__overlay__ {
		    #address-cells 	= <1>;
		    #size-cells 	= <0>;
		    status			= "okay";
		    pinctrl-names	= "default";
		    pinctrl-0		= <&bone_spi1_pins>;	
		    cs-gpios 		= <&gpio3 17 0>, <&gpio0 7 0>;

		    control{
		        #address-cells 	  = <1>;
		        #size-cells 	  = <0>;
		        compatible 		  = "spidev";
		        reg 			  = <0>;
		        spi-max-frequency = <16000000>;
		        spi-cpha;		  //control has mode 1 (CPOL = 0, CPHA = 1)
		    };

		    current{
		        #address-cells 	  = <1>;
		        #size-cells 	  = <0>;
		        compatible 		  = "spidev";
		        reg 			  = <1>;
		        spi-max-frequency = <16000000>;
		           				  //current has mode 0 (CPOL = 0, CPHA = 0)
		    };
		};
	};

	fragment@3 {
		target = <&tscadc>;
		__overlay__ {			
		    status = "okay";
		    adc {
		        ti,adc-channels = <1 3 5>;
		    };
		};
	};

};
